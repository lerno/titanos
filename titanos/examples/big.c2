/*
    This is snake example with copied/renamed functions to make a big program
*/
module big;

import stdio as io;
import string local;

#define ANSI_BLACK    "\033[0;30m"
#define ANSI_RED      "\033[0;31m"
#define ANSI_GREEN    "\033[0;32m"
#define ANSI_YELLOW   "\033[0;33m"
#define ANSI_BLUE     "\033[0;34m"
#define ANSI_MAGENTA  "\033[0;35m"
#define ANSI_CYAN     "\033[0;36m"
#define ANSI_GREY     "\033[0;37m"
#define ANSI_DARKGREY "\033[01;30m"
#define ANSI_BRED     "\033[01;31m"
#define ANSI_BGREEN   "\033[01;32m"
#define ANSI_BYELLOW  "\033[01;33m"
#define ANSI_BBLUE    "\033[01;34m"
#define ANSI_BMAGENTA "\033[01;35m"
#define ANSI_BCYAN    "\033[01;36m"
#define ANSI_WHITE    "\033[01;37m"
#define ANSI_NORMAL   "\033[0m"


public func i32 main() {
    aaa_calculate_rotations();
    aaa_board_init();
    aaa_board_try_piece(0);
    io.printf("%luM tries, found %d solutions\n", aaa_tried/1000000, aaa_found);
    return 0;
}

type Flags enum i8 {
    North = 1,
    East  = 2,
    South = 3,
    West  = 4,
    Head  = 5,
    Tail  = 6,
}

type FieldStatus enum i8 {
    Free = 0,
    Blocked,
    Taken,    // + index of piece
}

// ---- TEMPLATE aaa ------------------------------------------

type AaaCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 aaa_found;
u64 aaa_tried;

type AaaField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type AaaBoard struct {
    AaaField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type AaaPiece struct {
    AaaCoor[4] side1;
    AaaCoor[4] side2;
}

type AaaOption struct {
    AaaCoor[4] parts;
}

AaaBoard aaa_board;

AaaPiece[] aaa_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
AaaOption[AaaNumOptions][AaaNumPieces] aaa_options;

const i32 AaaNumPieces = elemsof(aaa_pieces);
const i32 AaaNumOptions = 8;


func AaaCoor aaa_coor_rotate(AaaCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    AaaCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void aaa_calculate_rotations() {
    memset(aaa_options, 0, sizeof(aaa_options));
    for (u32 p=0; p<AaaNumPieces; p++) {
        const AaaPiece* pp = &aaa_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            AaaOption* o1 = &aaa_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                AaaCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = aaa_coor_rotate(c, o);
            }
            AaaOption* o2 = &aaa_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                AaaCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = aaa_coor_rotate(c, o);
            }
        }
    }
}

func void aaa_board_set(i32 x, i32 y, AaaField field) {
    aaa_board.fields[x + y * 5] = field;
}

func AaaField aaa_board_get(i32 x, i32 y) {
    return aaa_board.fields[x + y * 5];
}

func void aaa_board_init() {
    AaaField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            aaa_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    aaa_board_set(0, 4, f);
    aaa_board.haveHead = 0;
    aaa_board.haveTail = 0;
}

func char aaa_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void aaa_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", aaa_board.haveHead, aaa_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            AaaField field = aaa_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, aaa_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, aaa_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = aaa_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 aaa_board_check_fault(i32 xx, i32 yy, i32 expect) {
    AaaField f = aaa_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 aaa_board_try_option(const AaaOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        AaaCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        AaaField f = aaa_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (aaa_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (aaa_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (aaa_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (aaa_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (aaa_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (aaa_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void aaa_board_clearflags(i32 x, i32 y) {
    aaa_board.fields[x + y * 5].expected = 0;
}

func void aaa_board_setExpected(i32 x, i32 y, u8 side) {
    aaa_board.fields[x + y * 5].expected = side;
}

func void aaa_board_add(const AaaOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        AaaCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        AaaField field = aaa_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        aaa_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            aaa_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            aaa_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            aaa_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            aaa_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            aaa_board.haveHead = 1;
            break;
        case Flags.Tail:
            aaa_board.haveTail = 1;
            break;
        }
    }
}

func void aaa_board_rem(const AaaOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        AaaCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        AaaField field = aaa_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        aaa_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            aaa_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            aaa_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            aaa_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            aaa_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            aaa_board.haveHead = 0;
            break;
        case Flags.Tail:
            aaa_board.haveTail = 0;
            break;
        }
    }
}

func void aaa_board_try_piece(u8 p) {
    if (p == AaaNumPieces) {
        aaa_found++;
        io.printf("Found solution %u\n", aaa_found);
        aaa_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            AaaField f = aaa_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<AaaNumOptions; o++) {
                if (!aaa_board_try_option(&aaa_options[o][p], x, y)) {
                    aaa_board_add(&aaa_options[o][p], x, y, p);
                    aaa_board_try_piece(p+1);
                    aaa_board_rem(&aaa_options[o][p], x, y);
                }
                aaa_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE bbb ------------------------------------------

type BbbCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 bbb_found;
u64 bbb_tried;

type BbbField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type BbbBoard struct {
    BbbField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type BbbPiece struct {
    BbbCoor[4] side1;
    BbbCoor[4] side2;
}

type BbbOption struct {
    BbbCoor[4] parts;
}

BbbBoard bbb_board;

BbbPiece[] bbb_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
BbbOption[BbbNumOptions][BbbNumPieces] bbb_options;

const i32 BbbNumPieces = elemsof(bbb_pieces);
const i32 BbbNumOptions = 8;


func BbbCoor bbb_coor_rotate(BbbCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    BbbCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void bbb_calculate_rotations() {
    memset(bbb_options, 0, sizeof(bbb_options));
    for (u32 p=0; p<BbbNumPieces; p++) {
        const BbbPiece* pp = &bbb_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            BbbOption* o1 = &bbb_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                BbbCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = bbb_coor_rotate(c, o);
            }
            BbbOption* o2 = &bbb_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                BbbCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = bbb_coor_rotate(c, o);
            }
        }
    }
}

func void bbb_board_set(i32 x, i32 y, BbbField field) {
    bbb_board.fields[x + y * 5] = field;
}

func BbbField bbb_board_get(i32 x, i32 y) {
    return bbb_board.fields[x + y * 5];
}

func void bbb_board_init() {
    BbbField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            bbb_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    bbb_board_set(0, 4, f);
    bbb_board.haveHead = 0;
    bbb_board.haveTail = 0;
}

func char bbb_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void bbb_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", bbb_board.haveHead, bbb_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            BbbField field = bbb_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, bbb_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, bbb_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = bbb_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 bbb_board_check_fault(i32 xx, i32 yy, i32 expect) {
    BbbField f = bbb_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 bbb_board_try_option(const BbbOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        BbbCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        BbbField f = bbb_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (bbb_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (bbb_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (bbb_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (bbb_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (bbb_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (bbb_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void bbb_board_clearflags(i32 x, i32 y) {
    bbb_board.fields[x + y * 5].expected = 0;
}

func void bbb_board_setExpected(i32 x, i32 y, u8 side) {
    bbb_board.fields[x + y * 5].expected = side;
}

func void bbb_board_add(const BbbOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        BbbCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        BbbField field = bbb_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        bbb_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            bbb_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            bbb_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            bbb_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            bbb_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            bbb_board.haveHead = 1;
            break;
        case Flags.Tail:
            bbb_board.haveTail = 1;
            break;
        }
    }
}

func void bbb_board_rem(const BbbOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        BbbCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        BbbField field = bbb_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        bbb_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            bbb_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            bbb_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            bbb_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            bbb_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            bbb_board.haveHead = 0;
            break;
        case Flags.Tail:
            bbb_board.haveTail = 0;
            break;
        }
    }
}

func void bbb_board_try_piece(u8 p) {
    if (p == BbbNumPieces) {
        bbb_found++;
        io.printf("Found solution %u\n", bbb_found);
        bbb_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            BbbField f = bbb_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<BbbNumOptions; o++) {
                if (!bbb_board_try_option(&bbb_options[o][p], x, y)) {
                    bbb_board_add(&bbb_options[o][p], x, y, p);
                    bbb_board_try_piece(p+1);
                    bbb_board_rem(&bbb_options[o][p], x, y);
                }
                bbb_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ccc ------------------------------------------

type CccCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 ccc_found;
u64 ccc_tried;

type CccField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type CccBoard struct {
    CccField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type CccPiece struct {
    CccCoor[4] side1;
    CccCoor[4] side2;
}

type CccOption struct {
    CccCoor[4] parts;
}

CccBoard ccc_board;

CccPiece[] ccc_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
CccOption[CccNumOptions][CccNumPieces] ccc_options;

const i32 CccNumPieces = elemsof(ccc_pieces);
const i32 CccNumOptions = 8;


func CccCoor ccc_coor_rotate(CccCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    CccCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ccc_calculate_rotations() {
    memset(ccc_options, 0, sizeof(ccc_options));
    for (u32 p=0; p<CccNumPieces; p++) {
        const CccPiece* pp = &ccc_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            CccOption* o1 = &ccc_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                CccCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = ccc_coor_rotate(c, o);
            }
            CccOption* o2 = &ccc_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                CccCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = ccc_coor_rotate(c, o);
            }
        }
    }
}

func void ccc_board_set(i32 x, i32 y, CccField field) {
    ccc_board.fields[x + y * 5] = field;
}

func CccField ccc_board_get(i32 x, i32 y) {
    return ccc_board.fields[x + y * 5];
}

func void ccc_board_init() {
    CccField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            ccc_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    ccc_board_set(0, 4, f);
    ccc_board.haveHead = 0;
    ccc_board.haveTail = 0;
}

func char ccc_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void ccc_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ccc_board.haveHead, ccc_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            CccField field = ccc_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ccc_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ccc_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ccc_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 ccc_board_check_fault(i32 xx, i32 yy, i32 expect) {
    CccField f = ccc_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 ccc_board_try_option(const CccOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        CccCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        CccField f = ccc_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (ccc_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (ccc_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (ccc_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (ccc_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (ccc_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (ccc_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ccc_board_clearflags(i32 x, i32 y) {
    ccc_board.fields[x + y * 5].expected = 0;
}

func void ccc_board_setExpected(i32 x, i32 y, u8 side) {
    ccc_board.fields[x + y * 5].expected = side;
}

func void ccc_board_add(const CccOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        CccCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        CccField field = ccc_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        ccc_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ccc_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            ccc_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            ccc_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            ccc_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            ccc_board.haveHead = 1;
            break;
        case Flags.Tail:
            ccc_board.haveTail = 1;
            break;
        }
    }
}

func void ccc_board_rem(const CccOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        CccCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        CccField field = ccc_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        ccc_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ccc_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            ccc_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            ccc_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            ccc_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            ccc_board.haveHead = 0;
            break;
        case Flags.Tail:
            ccc_board.haveTail = 0;
            break;
        }
    }
}

func void ccc_board_try_piece(u8 p) {
    if (p == CccNumPieces) {
        ccc_found++;
        io.printf("Found solution %u\n", ccc_found);
        ccc_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            CccField f = ccc_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<CccNumOptions; o++) {
                if (!ccc_board_try_option(&ccc_options[o][p], x, y)) {
                    ccc_board_add(&ccc_options[o][p], x, y, p);
                    ccc_board_try_piece(p+1);
                    ccc_board_rem(&ccc_options[o][p], x, y);
                }
                ccc_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ddd ------------------------------------------

type DddCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 ddd_found;
u64 ddd_tried;

type DddField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type DddBoard struct {
    DddField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type DddPiece struct {
    DddCoor[4] side1;
    DddCoor[4] side2;
}

type DddOption struct {
    DddCoor[4] parts;
}

DddBoard ddd_board;

DddPiece[] ddd_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
DddOption[DddNumOptions][DddNumPieces] ddd_options;

const i32 DddNumPieces = elemsof(ddd_pieces);
const i32 DddNumOptions = 8;


func DddCoor ddd_coor_rotate(DddCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    DddCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ddd_calculate_rotations() {
    memset(ddd_options, 0, sizeof(ddd_options));
    for (u32 p=0; p<DddNumPieces; p++) {
        const DddPiece* pp = &ddd_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            DddOption* o1 = &ddd_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                DddCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = ddd_coor_rotate(c, o);
            }
            DddOption* o2 = &ddd_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                DddCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = ddd_coor_rotate(c, o);
            }
        }
    }
}

func void ddd_board_set(i32 x, i32 y, DddField field) {
    ddd_board.fields[x + y * 5] = field;
}

func DddField ddd_board_get(i32 x, i32 y) {
    return ddd_board.fields[x + y * 5];
}

func void ddd_board_init() {
    DddField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            ddd_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    ddd_board_set(0, 4, f);
    ddd_board.haveHead = 0;
    ddd_board.haveTail = 0;
}

func char ddd_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void ddd_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ddd_board.haveHead, ddd_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            DddField field = ddd_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ddd_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ddd_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ddd_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 ddd_board_check_fault(i32 xx, i32 yy, i32 expect) {
    DddField f = ddd_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 ddd_board_try_option(const DddOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        DddCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        DddField f = ddd_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (ddd_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (ddd_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (ddd_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (ddd_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (ddd_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (ddd_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ddd_board_clearflags(i32 x, i32 y) {
    ddd_board.fields[x + y * 5].expected = 0;
}

func void ddd_board_setExpected(i32 x, i32 y, u8 side) {
    ddd_board.fields[x + y * 5].expected = side;
}

func void ddd_board_add(const DddOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        DddCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        DddField field = ddd_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        ddd_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ddd_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            ddd_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            ddd_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            ddd_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            ddd_board.haveHead = 1;
            break;
        case Flags.Tail:
            ddd_board.haveTail = 1;
            break;
        }
    }
}

func void ddd_board_rem(const DddOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        DddCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        DddField field = ddd_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        ddd_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ddd_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            ddd_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            ddd_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            ddd_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            ddd_board.haveHead = 0;
            break;
        case Flags.Tail:
            ddd_board.haveTail = 0;
            break;
        }
    }
}

func void ddd_board_try_piece(u8 p) {
    if (p == DddNumPieces) {
        ddd_found++;
        io.printf("Found solution %u\n", ddd_found);
        ddd_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            DddField f = ddd_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<DddNumOptions; o++) {
                if (!ddd_board_try_option(&ddd_options[o][p], x, y)) {
                    ddd_board_add(&ddd_options[o][p], x, y, p);
                    ddd_board_try_piece(p+1);
                    ddd_board_rem(&ddd_options[o][p], x, y);
                }
                ddd_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE eee ------------------------------------------

type EeeCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 eee_found;
u64 eee_tried;

type EeeField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type EeeBoard struct {
    EeeField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type EeePiece struct {
    EeeCoor[4] side1;
    EeeCoor[4] side2;
}

type EeeOption struct {
    EeeCoor[4] parts;
}

EeeBoard eee_board;

EeePiece[] eee_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
EeeOption[EeeNumOptions][EeeNumPieces] eee_options;

const i32 EeeNumPieces = elemsof(eee_pieces);
const i32 EeeNumOptions = 8;


func EeeCoor eee_coor_rotate(EeeCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    EeeCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void eee_calculate_rotations() {
    memset(eee_options, 0, sizeof(eee_options));
    for (u32 p=0; p<EeeNumPieces; p++) {
        const EeePiece* pp = &eee_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            EeeOption* o1 = &eee_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                EeeCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = eee_coor_rotate(c, o);
            }
            EeeOption* o2 = &eee_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                EeeCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = eee_coor_rotate(c, o);
            }
        }
    }
}

func void eee_board_set(i32 x, i32 y, EeeField field) {
    eee_board.fields[x + y * 5] = field;
}

func EeeField eee_board_get(i32 x, i32 y) {
    return eee_board.fields[x + y * 5];
}

func void eee_board_init() {
    EeeField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            eee_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    eee_board_set(0, 4, f);
    eee_board.haveHead = 0;
    eee_board.haveTail = 0;
}

func char eee_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void eee_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", eee_board.haveHead, eee_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            EeeField field = eee_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, eee_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, eee_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = eee_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 eee_board_check_fault(i32 xx, i32 yy, i32 expect) {
    EeeField f = eee_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 eee_board_try_option(const EeeOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        EeeCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        EeeField f = eee_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (eee_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (eee_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (eee_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (eee_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (eee_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (eee_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void eee_board_clearflags(i32 x, i32 y) {
    eee_board.fields[x + y * 5].expected = 0;
}

func void eee_board_setExpected(i32 x, i32 y, u8 side) {
    eee_board.fields[x + y * 5].expected = side;
}

func void eee_board_add(const EeeOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        EeeCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        EeeField field = eee_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        eee_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            eee_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            eee_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            eee_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            eee_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            eee_board.haveHead = 1;
            break;
        case Flags.Tail:
            eee_board.haveTail = 1;
            break;
        }
    }
}

func void eee_board_rem(const EeeOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        EeeCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        EeeField field = eee_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        eee_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            eee_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            eee_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            eee_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            eee_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            eee_board.haveHead = 0;
            break;
        case Flags.Tail:
            eee_board.haveTail = 0;
            break;
        }
    }
}

func void eee_board_try_piece(u8 p) {
    if (p == EeeNumPieces) {
        eee_found++;
        io.printf("Found solution %u\n", eee_found);
        eee_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            EeeField f = eee_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<EeeNumOptions; o++) {
                if (!eee_board_try_option(&eee_options[o][p], x, y)) {
                    eee_board_add(&eee_options[o][p], x, y, p);
                    eee_board_try_piece(p+1);
                    eee_board_rem(&eee_options[o][p], x, y);
                }
                eee_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE fff ------------------------------------------

type FffCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 fff_found;
u64 fff_tried;

type FffField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type FffBoard struct {
    FffField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type FffPiece struct {
    FffCoor[4] side1;
    FffCoor[4] side2;
}

type FffOption struct {
    FffCoor[4] parts;
}

FffBoard fff_board;

FffPiece[] fff_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
FffOption[FffNumOptions][FffNumPieces] fff_options;

const i32 FffNumPieces = elemsof(fff_pieces);
const i32 FffNumOptions = 8;


func FffCoor fff_coor_rotate(FffCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    FffCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void fff_calculate_rotations() {
    memset(fff_options, 0, sizeof(fff_options));
    for (u32 p=0; p<FffNumPieces; p++) {
        const FffPiece* pp = &fff_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            FffOption* o1 = &fff_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                FffCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = fff_coor_rotate(c, o);
            }
            FffOption* o2 = &fff_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                FffCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = fff_coor_rotate(c, o);
            }
        }
    }
}

func void fff_board_set(i32 x, i32 y, FffField field) {
    fff_board.fields[x + y * 5] = field;
}

func FffField fff_board_get(i32 x, i32 y) {
    return fff_board.fields[x + y * 5];
}

func void fff_board_init() {
    FffField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            fff_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    fff_board_set(0, 4, f);
    fff_board.haveHead = 0;
    fff_board.haveTail = 0;
}

func char fff_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void fff_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", fff_board.haveHead, fff_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            FffField field = fff_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, fff_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, fff_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = fff_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 fff_board_check_fault(i32 xx, i32 yy, i32 expect) {
    FffField f = fff_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 fff_board_try_option(const FffOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        FffCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        FffField f = fff_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (fff_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (fff_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (fff_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (fff_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (fff_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (fff_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void fff_board_clearflags(i32 x, i32 y) {
    fff_board.fields[x + y * 5].expected = 0;
}

func void fff_board_setExpected(i32 x, i32 y, u8 side) {
    fff_board.fields[x + y * 5].expected = side;
}

func void fff_board_add(const FffOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        FffCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        FffField field = fff_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        fff_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            fff_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            fff_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            fff_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            fff_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            fff_board.haveHead = 1;
            break;
        case Flags.Tail:
            fff_board.haveTail = 1;
            break;
        }
    }
}

func void fff_board_rem(const FffOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        FffCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        FffField field = fff_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        fff_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            fff_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            fff_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            fff_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            fff_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            fff_board.haveHead = 0;
            break;
        case Flags.Tail:
            fff_board.haveTail = 0;
            break;
        }
    }
}

func void fff_board_try_piece(u8 p) {
    if (p == FffNumPieces) {
        fff_found++;
        io.printf("Found solution %u\n", fff_found);
        fff_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            FffField f = fff_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<FffNumOptions; o++) {
                if (!fff_board_try_option(&fff_options[o][p], x, y)) {
                    fff_board_add(&fff_options[o][p], x, y, p);
                    fff_board_try_piece(p+1);
                    fff_board_rem(&fff_options[o][p], x, y);
                }
                fff_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ggg ------------------------------------------

type GggCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 ggg_found;
u64 ggg_tried;

type GggField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type GggBoard struct {
    GggField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type GggPiece struct {
    GggCoor[4] side1;
    GggCoor[4] side2;
}

type GggOption struct {
    GggCoor[4] parts;
}

GggBoard ggg_board;

GggPiece[] ggg_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
GggOption[GggNumOptions][GggNumPieces] ggg_options;

const i32 GggNumPieces = elemsof(ggg_pieces);
const i32 GggNumOptions = 8;


func GggCoor ggg_coor_rotate(GggCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    GggCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ggg_calculate_rotations() {
    memset(ggg_options, 0, sizeof(ggg_options));
    for (u32 p=0; p<GggNumPieces; p++) {
        const GggPiece* pp = &ggg_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            GggOption* o1 = &ggg_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                GggCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = ggg_coor_rotate(c, o);
            }
            GggOption* o2 = &ggg_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                GggCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = ggg_coor_rotate(c, o);
            }
        }
    }
}

func void ggg_board_set(i32 x, i32 y, GggField field) {
    ggg_board.fields[x + y * 5] = field;
}

func GggField ggg_board_get(i32 x, i32 y) {
    return ggg_board.fields[x + y * 5];
}

func void ggg_board_init() {
    GggField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            ggg_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    ggg_board_set(0, 4, f);
    ggg_board.haveHead = 0;
    ggg_board.haveTail = 0;
}

func char ggg_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void ggg_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ggg_board.haveHead, ggg_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            GggField field = ggg_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ggg_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ggg_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ggg_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 ggg_board_check_fault(i32 xx, i32 yy, i32 expect) {
    GggField f = ggg_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 ggg_board_try_option(const GggOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        GggCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        GggField f = ggg_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (ggg_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (ggg_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (ggg_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (ggg_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (ggg_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (ggg_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ggg_board_clearflags(i32 x, i32 y) {
    ggg_board.fields[x + y * 5].expected = 0;
}

func void ggg_board_setExpected(i32 x, i32 y, u8 side) {
    ggg_board.fields[x + y * 5].expected = side;
}

func void ggg_board_add(const GggOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        GggCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        GggField field = ggg_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        ggg_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ggg_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            ggg_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            ggg_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            ggg_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            ggg_board.haveHead = 1;
            break;
        case Flags.Tail:
            ggg_board.haveTail = 1;
            break;
        }
    }
}

func void ggg_board_rem(const GggOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        GggCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        GggField field = ggg_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        ggg_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ggg_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            ggg_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            ggg_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            ggg_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            ggg_board.haveHead = 0;
            break;
        case Flags.Tail:
            ggg_board.haveTail = 0;
            break;
        }
    }
}

func void ggg_board_try_piece(u8 p) {
    if (p == GggNumPieces) {
        ggg_found++;
        io.printf("Found solution %u\n", ggg_found);
        ggg_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            GggField f = ggg_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<GggNumOptions; o++) {
                if (!ggg_board_try_option(&ggg_options[o][p], x, y)) {
                    ggg_board_add(&ggg_options[o][p], x, y, p);
                    ggg_board_try_piece(p+1);
                    ggg_board_rem(&ggg_options[o][p], x, y);
                }
                ggg_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE hhh ------------------------------------------

type HhhCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 hhh_found;
u64 hhh_tried;

type HhhField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type HhhBoard struct {
    HhhField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type HhhPiece struct {
    HhhCoor[4] side1;
    HhhCoor[4] side2;
}

type HhhOption struct {
    HhhCoor[4] parts;
}

HhhBoard hhh_board;

HhhPiece[] hhh_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
HhhOption[HhhNumOptions][HhhNumPieces] hhh_options;

const i32 HhhNumPieces = elemsof(hhh_pieces);
const i32 HhhNumOptions = 8;


func HhhCoor hhh_coor_rotate(HhhCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    HhhCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void hhh_calculate_rotations() {
    memset(hhh_options, 0, sizeof(hhh_options));
    for (u32 p=0; p<HhhNumPieces; p++) {
        const HhhPiece* pp = &hhh_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            HhhOption* o1 = &hhh_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                HhhCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = hhh_coor_rotate(c, o);
            }
            HhhOption* o2 = &hhh_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                HhhCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = hhh_coor_rotate(c, o);
            }
        }
    }
}

func void hhh_board_set(i32 x, i32 y, HhhField field) {
    hhh_board.fields[x + y * 5] = field;
}

func HhhField hhh_board_get(i32 x, i32 y) {
    return hhh_board.fields[x + y * 5];
}

func void hhh_board_init() {
    HhhField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            hhh_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    hhh_board_set(0, 4, f);
    hhh_board.haveHead = 0;
    hhh_board.haveTail = 0;
}

func char hhh_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void hhh_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", hhh_board.haveHead, hhh_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            HhhField field = hhh_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, hhh_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, hhh_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = hhh_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 hhh_board_check_fault(i32 xx, i32 yy, i32 expect) {
    HhhField f = hhh_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 hhh_board_try_option(const HhhOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        HhhCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        HhhField f = hhh_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (hhh_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (hhh_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (hhh_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (hhh_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (hhh_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (hhh_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void hhh_board_clearflags(i32 x, i32 y) {
    hhh_board.fields[x + y * 5].expected = 0;
}

func void hhh_board_setExpected(i32 x, i32 y, u8 side) {
    hhh_board.fields[x + y * 5].expected = side;
}

func void hhh_board_add(const HhhOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        HhhCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        HhhField field = hhh_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        hhh_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            hhh_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            hhh_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            hhh_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            hhh_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            hhh_board.haveHead = 1;
            break;
        case Flags.Tail:
            hhh_board.haveTail = 1;
            break;
        }
    }
}

func void hhh_board_rem(const HhhOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        HhhCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        HhhField field = hhh_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        hhh_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            hhh_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            hhh_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            hhh_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            hhh_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            hhh_board.haveHead = 0;
            break;
        case Flags.Tail:
            hhh_board.haveTail = 0;
            break;
        }
    }
}

func void hhh_board_try_piece(u8 p) {
    if (p == HhhNumPieces) {
        hhh_found++;
        io.printf("Found solution %u\n", hhh_found);
        hhh_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            HhhField f = hhh_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<HhhNumOptions; o++) {
                if (!hhh_board_try_option(&hhh_options[o][p], x, y)) {
                    hhh_board_add(&hhh_options[o][p], x, y, p);
                    hhh_board_try_piece(p+1);
                    hhh_board_rem(&hhh_options[o][p], x, y);
                }
                hhh_tried++;
                if (p==0) break;
            }
        }
    }
}


// ---- TEMPLATE iii ------------------------------------------

type IiiCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 iii_found;
u64 iii_tried;

type IiiField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type IiiBoard struct {
    IiiField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type IiiPiece struct {
    IiiCoor[4] side1;
    IiiCoor[4] side2;
}

type IiiOption struct {
    IiiCoor[4] parts;
}

IiiBoard iii_board;

IiiPiece[] iii_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
IiiOption[IiiNumOptions][IiiNumPieces] iii_options;

const i32 IiiNumPieces = elemsof(iii_pieces);
const i32 IiiNumOptions = 8;


func IiiCoor iii_coor_rotate(IiiCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    IiiCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void iii_calculate_rotations() {
    memset(iii_options, 0, sizeof(iii_options));
    for (u32 p=0; p<IiiNumPieces; p++) {
        const IiiPiece* pp = &iii_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            IiiOption* o1 = &iii_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                IiiCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = iii_coor_rotate(c, o);
            }
            IiiOption* o2 = &iii_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                IiiCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = iii_coor_rotate(c, o);
            }
        }
    }
}

func void iii_board_set(i32 x, i32 y, IiiField field) {
    iii_board.fields[x + y * 5] = field;
}

func IiiField iii_board_get(i32 x, i32 y) {
    return iii_board.fields[x + y * 5];
}

func void iii_board_init() {
    IiiField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            iii_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    iii_board_set(0, 4, f);
    iii_board.haveHead = 0;
    iii_board.haveTail = 0;
}

func char iii_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void iii_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", iii_board.haveHead, iii_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            IiiField field = iii_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, iii_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, iii_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = iii_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 iii_board_check_fault(i32 xx, i32 yy, i32 expect) {
    IiiField f = iii_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 iii_board_try_option(const IiiOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        IiiCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        IiiField f = iii_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (iii_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (iii_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (iii_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (iii_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (iii_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (iii_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void iii_board_clearflags(i32 x, i32 y) {
    iii_board.fields[x + y * 5].expected = 0;
}

func void iii_board_setExpected(i32 x, i32 y, u8 side) {
    iii_board.fields[x + y * 5].expected = side;
}

func void iii_board_add(const IiiOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        IiiCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        IiiField field = iii_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        iii_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            iii_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            iii_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            iii_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            iii_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            iii_board.haveHead = 1;
            break;
        case Flags.Tail:
            iii_board.haveTail = 1;
            break;
        }
    }
}

func void iii_board_rem(const IiiOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        IiiCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        IiiField field = iii_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        iii_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            iii_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            iii_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            iii_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            iii_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            iii_board.haveHead = 0;
            break;
        case Flags.Tail:
            iii_board.haveTail = 0;
            break;
        }
    }
}

func void iii_board_try_piece(u8 p) {
    if (p == IiiNumPieces) {
        iii_found++;
        io.printf("Found solution %u\n", iii_found);
        iii_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            IiiField f = iii_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<IiiNumOptions; o++) {
                if (!iii_board_try_option(&iii_options[o][p], x, y)) {
                    iii_board_add(&iii_options[o][p], x, y, p);
                    iii_board_try_piece(p+1);
                    iii_board_rem(&iii_options[o][p], x, y);
                }
                iii_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE jjj ------------------------------------------

type JjjCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 jjj_found;
u64 jjj_tried;

type JjjField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type JjjBoard struct {
    JjjField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type JjjPiece struct {
    JjjCoor[4] side1;
    JjjCoor[4] side2;
}

type JjjOption struct {
    JjjCoor[4] parts;
}

JjjBoard jjj_board;

JjjPiece[] jjj_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
JjjOption[JjjNumOptions][JjjNumPieces] jjj_options;

const i32 JjjNumPieces = elemsof(jjj_pieces);
const i32 JjjNumOptions = 8;


func JjjCoor jjj_coor_rotate(JjjCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    JjjCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void jjj_calculate_rotations() {
    memset(jjj_options, 0, sizeof(jjj_options));
    for (u32 p=0; p<JjjNumPieces; p++) {
        const JjjPiece* pp = &jjj_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            JjjOption* o1 = &jjj_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                JjjCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = jjj_coor_rotate(c, o);
            }
            JjjOption* o2 = &jjj_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                JjjCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = jjj_coor_rotate(c, o);
            }
        }
    }
}

func void jjj_board_set(i32 x, i32 y, JjjField field) {
    jjj_board.fields[x + y * 5] = field;
}

func JjjField jjj_board_get(i32 x, i32 y) {
    return jjj_board.fields[x + y * 5];
}

func void jjj_board_init() {
    JjjField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            jjj_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    jjj_board_set(0, 4, f);
    jjj_board.haveHead = 0;
    jjj_board.haveTail = 0;
}

func char jjj_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void jjj_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", jjj_board.haveHead, jjj_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            JjjField field = jjj_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, jjj_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, jjj_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = jjj_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 jjj_board_check_fault(i32 xx, i32 yy, i32 expect) {
    JjjField f = jjj_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 jjj_board_try_option(const JjjOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        JjjCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        JjjField f = jjj_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (jjj_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (jjj_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (jjj_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (jjj_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (jjj_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (jjj_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void jjj_board_clearflags(i32 x, i32 y) {
    jjj_board.fields[x + y * 5].expected = 0;
}

func void jjj_board_setExpected(i32 x, i32 y, u8 side) {
    jjj_board.fields[x + y * 5].expected = side;
}

func void jjj_board_add(const JjjOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        JjjCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        JjjField field = jjj_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        jjj_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            jjj_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            jjj_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            jjj_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            jjj_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            jjj_board.haveHead = 1;
            break;
        case Flags.Tail:
            jjj_board.haveTail = 1;
            break;
        }
    }
}

func void jjj_board_rem(const JjjOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        JjjCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        JjjField field = jjj_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        jjj_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            jjj_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            jjj_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            jjj_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            jjj_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            jjj_board.haveHead = 0;
            break;
        case Flags.Tail:
            jjj_board.haveTail = 0;
            break;
        }
    }
}

func void jjj_board_try_piece(u8 p) {
    if (p == JjjNumPieces) {
        jjj_found++;
        io.printf("Found solution %u\n", jjj_found);
        jjj_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            JjjField f = jjj_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<JjjNumOptions; o++) {
                if (!jjj_board_try_option(&jjj_options[o][p], x, y)) {
                    jjj_board_add(&jjj_options[o][p], x, y, p);
                    jjj_board_try_piece(p+1);
                    jjj_board_rem(&jjj_options[o][p], x, y);
                }
                jjj_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE kkk ------------------------------------------

type KkkCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 kkk_found;
u64 kkk_tried;

type KkkField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type KkkBoard struct {
    KkkField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type KkkPiece struct {
    KkkCoor[4] side1;
    KkkCoor[4] side2;
}

type KkkOption struct {
    KkkCoor[4] parts;
}

KkkBoard kkk_board;

KkkPiece[] kkk_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
KkkOption[KkkNumOptions][KkkNumPieces] kkk_options;

const i32 KkkNumPieces = elemsof(kkk_pieces);
const i32 KkkNumOptions = 8;


func KkkCoor kkk_coor_rotate(KkkCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    KkkCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void kkk_calculate_rotations() {
    memset(kkk_options, 0, sizeof(kkk_options));
    for (u32 p=0; p<KkkNumPieces; p++) {
        const KkkPiece* pp = &kkk_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            KkkOption* o1 = &kkk_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                KkkCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = kkk_coor_rotate(c, o);
            }
            KkkOption* o2 = &kkk_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                KkkCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = kkk_coor_rotate(c, o);
            }
        }
    }
}

func void kkk_board_set(i32 x, i32 y, KkkField field) {
    kkk_board.fields[x + y * 5] = field;
}

func KkkField kkk_board_get(i32 x, i32 y) {
    return kkk_board.fields[x + y * 5];
}

func void kkk_board_init() {
    KkkField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            kkk_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    kkk_board_set(0, 4, f);
    kkk_board.haveHead = 0;
    kkk_board.haveTail = 0;
}

func char kkk_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void kkk_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", kkk_board.haveHead, kkk_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            KkkField field = kkk_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, kkk_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, kkk_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = kkk_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 kkk_board_check_fault(i32 xx, i32 yy, i32 expect) {
    KkkField f = kkk_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 kkk_board_try_option(const KkkOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        KkkCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        KkkField f = kkk_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (kkk_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (kkk_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (kkk_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (kkk_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (kkk_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (kkk_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void kkk_board_clearflags(i32 x, i32 y) {
    kkk_board.fields[x + y * 5].expected = 0;
}

func void kkk_board_setExpected(i32 x, i32 y, u8 side) {
    kkk_board.fields[x + y * 5].expected = side;
}

func void kkk_board_add(const KkkOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        KkkCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        KkkField field = kkk_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        kkk_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            kkk_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            kkk_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            kkk_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            kkk_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            kkk_board.haveHead = 1;
            break;
        case Flags.Tail:
            kkk_board.haveTail = 1;
            break;
        }
    }
}

func void kkk_board_rem(const KkkOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        KkkCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        KkkField field = kkk_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        kkk_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            kkk_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            kkk_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            kkk_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            kkk_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            kkk_board.haveHead = 0;
            break;
        case Flags.Tail:
            kkk_board.haveTail = 0;
            break;
        }
    }
}

func void kkk_board_try_piece(u8 p) {
    if (p == KkkNumPieces) {
        kkk_found++;
        io.printf("Found solution %u\n", kkk_found);
        kkk_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            KkkField f = kkk_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<KkkNumOptions; o++) {
                if (!kkk_board_try_option(&kkk_options[o][p], x, y)) {
                    kkk_board_add(&kkk_options[o][p], x, y, p);
                    kkk_board_try_piece(p+1);
                    kkk_board_rem(&kkk_options[o][p], x, y);
                }
                kkk_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE lll ------------------------------------------

type LllCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 lll_found;
u64 lll_tried;

type LllField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type LllBoard struct {
    LllField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type LllPiece struct {
    LllCoor[4] side1;
    LllCoor[4] side2;
}

type LllOption struct {
    LllCoor[4] parts;
}

LllBoard lll_board;

LllPiece[] lll_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
LllOption[LllNumOptions][LllNumPieces] lll_options;

const i32 LllNumPieces = elemsof(lll_pieces);
const i32 LllNumOptions = 8;


func LllCoor lll_coor_rotate(LllCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    LllCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void lll_calculate_rotations() {
    memset(lll_options, 0, sizeof(lll_options));
    for (u32 p=0; p<LllNumPieces; p++) {
        const LllPiece* pp = &lll_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            LllOption* o1 = &lll_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                LllCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = lll_coor_rotate(c, o);
            }
            LllOption* o2 = &lll_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                LllCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = lll_coor_rotate(c, o);
            }
        }
    }
}

func void lll_board_set(i32 x, i32 y, LllField field) {
    lll_board.fields[x + y * 5] = field;
}

func LllField lll_board_get(i32 x, i32 y) {
    return lll_board.fields[x + y * 5];
}

func void lll_board_init() {
    LllField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            lll_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    lll_board_set(0, 4, f);
    lll_board.haveHead = 0;
    lll_board.haveTail = 0;
}

func char lll_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void lll_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", lll_board.haveHead, lll_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            LllField field = lll_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, lll_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, lll_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = lll_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 lll_board_check_fault(i32 xx, i32 yy, i32 expect) {
    LllField f = lll_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 lll_board_try_option(const LllOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        LllCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        LllField f = lll_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (lll_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (lll_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (lll_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (lll_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (lll_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (lll_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void lll_board_clearflags(i32 x, i32 y) {
    lll_board.fields[x + y * 5].expected = 0;
}

func void lll_board_setExpected(i32 x, i32 y, u8 side) {
    lll_board.fields[x + y * 5].expected = side;
}

func void lll_board_add(const LllOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        LllCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        LllField field = lll_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        lll_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            lll_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            lll_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            lll_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            lll_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            lll_board.haveHead = 1;
            break;
        case Flags.Tail:
            lll_board.haveTail = 1;
            break;
        }
    }
}

func void lll_board_rem(const LllOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        LllCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        LllField field = lll_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        lll_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            lll_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            lll_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            lll_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            lll_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            lll_board.haveHead = 0;
            break;
        case Flags.Tail:
            lll_board.haveTail = 0;
            break;
        }
    }
}

func void lll_board_try_piece(u8 p) {
    if (p == LllNumPieces) {
        lll_found++;
        io.printf("Found solution %u\n", lll_found);
        lll_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            LllField f = lll_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<LllNumOptions; o++) {
                if (!lll_board_try_option(&lll_options[o][p], x, y)) {
                    lll_board_add(&lll_options[o][p], x, y, p);
                    lll_board_try_piece(p+1);
                    lll_board_rem(&lll_options[o][p], x, y);
                }
                lll_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE mmm ------------------------------------------

type MmmCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 mmm_found;
u64 mmm_tried;

type MmmField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type MmmBoard struct {
    MmmField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type MmmPiece struct {
    MmmCoor[4] side1;
    MmmCoor[4] side2;
}

type MmmOption struct {
    MmmCoor[4] parts;
}

MmmBoard mmm_board;

MmmPiece[] mmm_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
MmmOption[MmmNumOptions][MmmNumPieces] mmm_options;

const i32 MmmNumPieces = elemsof(mmm_pieces);
const i32 MmmNumOptions = 8;


func MmmCoor mmm_coor_rotate(MmmCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    MmmCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void mmm_calculate_rotations() {
    memset(mmm_options, 0, sizeof(mmm_options));
    for (u32 p=0; p<MmmNumPieces; p++) {
        const MmmPiece* pp = &mmm_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            MmmOption* o1 = &mmm_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                MmmCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = mmm_coor_rotate(c, o);
            }
            MmmOption* o2 = &mmm_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                MmmCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = mmm_coor_rotate(c, o);
            }
        }
    }
}

func void mmm_board_set(i32 x, i32 y, MmmField field) {
    mmm_board.fields[x + y * 5] = field;
}

func MmmField mmm_board_get(i32 x, i32 y) {
    return mmm_board.fields[x + y * 5];
}

func void mmm_board_init() {
    MmmField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            mmm_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    mmm_board_set(0, 4, f);
    mmm_board.haveHead = 0;
    mmm_board.haveTail = 0;
}

func char mmm_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void mmm_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", mmm_board.haveHead, mmm_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            MmmField field = mmm_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, mmm_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, mmm_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = mmm_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 mmm_board_check_fault(i32 xx, i32 yy, i32 expect) {
    MmmField f = mmm_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 mmm_board_try_option(const MmmOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        MmmCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        MmmField f = mmm_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (mmm_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (mmm_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (mmm_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (mmm_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (mmm_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (mmm_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void mmm_board_clearflags(i32 x, i32 y) {
    mmm_board.fields[x + y * 5].expected = 0;
}

func void mmm_board_setExpected(i32 x, i32 y, u8 side) {
    mmm_board.fields[x + y * 5].expected = side;
}

func void mmm_board_add(const MmmOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        MmmCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        MmmField field = mmm_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        mmm_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            mmm_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            mmm_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            mmm_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            mmm_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            mmm_board.haveHead = 1;
            break;
        case Flags.Tail:
            mmm_board.haveTail = 1;
            break;
        }
    }
}

func void mmm_board_rem(const MmmOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        MmmCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        MmmField field = mmm_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        mmm_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            mmm_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            mmm_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            mmm_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            mmm_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            mmm_board.haveHead = 0;
            break;
        case Flags.Tail:
            mmm_board.haveTail = 0;
            break;
        }
    }
}

func void mmm_board_try_piece(u8 p) {
    if (p == MmmNumPieces) {
        mmm_found++;
        io.printf("Found solution %u\n", mmm_found);
        mmm_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            MmmField f = mmm_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<MmmNumOptions; o++) {
                if (!mmm_board_try_option(&mmm_options[o][p], x, y)) {
                    mmm_board_add(&mmm_options[o][p], x, y, p);
                    mmm_board_try_piece(p+1);
                    mmm_board_rem(&mmm_options[o][p], x, y);
                }
                mmm_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE nnn ------------------------------------------

type NnnCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 nnn_found;
u64 nnn_tried;

type NnnField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type NnnBoard struct {
    NnnField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type NnnPiece struct {
    NnnCoor[4] side1;
    NnnCoor[4] side2;
}

type NnnOption struct {
    NnnCoor[4] parts;
}

NnnBoard nnn_board;

NnnPiece[] nnn_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
NnnOption[NnnNumOptions][NnnNumPieces] nnn_options;

const i32 NnnNumPieces = elemsof(nnn_pieces);
const i32 NnnNumOptions = 8;


func NnnCoor nnn_coor_rotate(NnnCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    NnnCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void nnn_calculate_rotations() {
    memset(nnn_options, 0, sizeof(nnn_options));
    for (u32 p=0; p<NnnNumPieces; p++) {
        const NnnPiece* pp = &nnn_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            NnnOption* o1 = &nnn_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                NnnCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = nnn_coor_rotate(c, o);
            }
            NnnOption* o2 = &nnn_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                NnnCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = nnn_coor_rotate(c, o);
            }
        }
    }
}

func void nnn_board_set(i32 x, i32 y, NnnField field) {
    nnn_board.fields[x + y * 5] = field;
}

func NnnField nnn_board_get(i32 x, i32 y) {
    return nnn_board.fields[x + y * 5];
}

func void nnn_board_init() {
    NnnField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            nnn_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    nnn_board_set(0, 4, f);
    nnn_board.haveHead = 0;
    nnn_board.haveTail = 0;
}

func char nnn_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void nnn_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", nnn_board.haveHead, nnn_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            NnnField field = nnn_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, nnn_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, nnn_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = nnn_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 nnn_board_check_fault(i32 xx, i32 yy, i32 expect) {
    NnnField f = nnn_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 nnn_board_try_option(const NnnOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        NnnCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        NnnField f = nnn_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (nnn_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (nnn_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (nnn_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (nnn_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (nnn_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (nnn_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void nnn_board_clearflags(i32 x, i32 y) {
    nnn_board.fields[x + y * 5].expected = 0;
}

func void nnn_board_setExpected(i32 x, i32 y, u8 side) {
    nnn_board.fields[x + y * 5].expected = side;
}

func void nnn_board_add(const NnnOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        NnnCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        NnnField field = nnn_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        nnn_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            nnn_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            nnn_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            nnn_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            nnn_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            nnn_board.haveHead = 1;
            break;
        case Flags.Tail:
            nnn_board.haveTail = 1;
            break;
        }
    }
}

func void nnn_board_rem(const NnnOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        NnnCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        NnnField field = nnn_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        nnn_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            nnn_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            nnn_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            nnn_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            nnn_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            nnn_board.haveHead = 0;
            break;
        case Flags.Tail:
            nnn_board.haveTail = 0;
            break;
        }
    }
}

func void nnn_board_try_piece(u8 p) {
    if (p == NnnNumPieces) {
        nnn_found++;
        io.printf("Found solution %u\n", nnn_found);
        nnn_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            NnnField f = nnn_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<NnnNumOptions; o++) {
                if (!nnn_board_try_option(&nnn_options[o][p], x, y)) {
                    nnn_board_add(&nnn_options[o][p], x, y, p);
                    nnn_board_try_piece(p+1);
                    nnn_board_rem(&nnn_options[o][p], x, y);
                }
                nnn_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ooo ------------------------------------------

type OooCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 ooo_found;
u64 ooo_tried;

type OooField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type OooBoard struct {
    OooField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type OooPiece struct {
    OooCoor[4] side1;
    OooCoor[4] side2;
}

type OooOption struct {
    OooCoor[4] parts;
}

OooBoard ooo_board;

OooPiece[] ooo_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
OooOption[OooNumOptions][OooNumPieces] ooo_options;

const i32 OooNumPieces = elemsof(ooo_pieces);
const i32 OooNumOptions = 8;


func OooCoor ooo_coor_rotate(OooCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    OooCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ooo_calculate_rotations() {
    memset(ooo_options, 0, sizeof(ooo_options));
    for (u32 p=0; p<OooNumPieces; p++) {
        const OooPiece* pp = &ooo_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            OooOption* o1 = &ooo_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                OooCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = ooo_coor_rotate(c, o);
            }
            OooOption* o2 = &ooo_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                OooCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = ooo_coor_rotate(c, o);
            }
        }
    }
}

func void ooo_board_set(i32 x, i32 y, OooField field) {
    ooo_board.fields[x + y * 5] = field;
}

func OooField ooo_board_get(i32 x, i32 y) {
    return ooo_board.fields[x + y * 5];
}

func void ooo_board_init() {
    OooField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            ooo_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    ooo_board_set(0, 4, f);
    ooo_board.haveHead = 0;
    ooo_board.haveTail = 0;
}

func char ooo_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void ooo_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ooo_board.haveHead, ooo_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            OooField field = ooo_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ooo_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ooo_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ooo_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 ooo_board_check_fault(i32 xx, i32 yy, i32 expect) {
    OooField f = ooo_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 ooo_board_try_option(const OooOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        OooCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        OooField f = ooo_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (ooo_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (ooo_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (ooo_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (ooo_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (ooo_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (ooo_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ooo_board_clearflags(i32 x, i32 y) {
    ooo_board.fields[x + y * 5].expected = 0;
}

func void ooo_board_setExpected(i32 x, i32 y, u8 side) {
    ooo_board.fields[x + y * 5].expected = side;
}

func void ooo_board_add(const OooOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        OooCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        OooField field = ooo_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        ooo_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ooo_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            ooo_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            ooo_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            ooo_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            ooo_board.haveHead = 1;
            break;
        case Flags.Tail:
            ooo_board.haveTail = 1;
            break;
        }
    }
}

func void ooo_board_rem(const OooOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        OooCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        OooField field = ooo_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        ooo_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ooo_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            ooo_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            ooo_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            ooo_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            ooo_board.haveHead = 0;
            break;
        case Flags.Tail:
            ooo_board.haveTail = 0;
            break;
        }
    }
}

func void ooo_board_try_piece(u8 p) {
    if (p == OooNumPieces) {
        ooo_found++;
        io.printf("Found solution %u\n", ooo_found);
        ooo_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            OooField f = ooo_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<OooNumOptions; o++) {
                if (!ooo_board_try_option(&ooo_options[o][p], x, y)) {
                    ooo_board_add(&ooo_options[o][p], x, y, p);
                    ooo_board_try_piece(p+1);
                    ooo_board_rem(&ooo_options[o][p], x, y);
                }
                ooo_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ppp ------------------------------------------

type PppCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 ppp_found;
u64 ppp_tried;

type PppField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type PppBoard struct {
    PppField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type PppPiece struct {
    PppCoor[4] side1;
    PppCoor[4] side2;
}

type PppOption struct {
    PppCoor[4] parts;
}

PppBoard ppp_board;

PppPiece[] ppp_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
PppOption[PppNumOptions][PppNumPieces] ppp_options;

const i32 PppNumPieces = elemsof(ppp_pieces);
const i32 PppNumOptions = 8;


func PppCoor ppp_coor_rotate(PppCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    PppCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ppp_calculate_rotations() {
    memset(ppp_options, 0, sizeof(ppp_options));
    for (u32 p=0; p<PppNumPieces; p++) {
        const PppPiece* pp = &ppp_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            PppOption* o1 = &ppp_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                PppCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = ppp_coor_rotate(c, o);
            }
            PppOption* o2 = &ppp_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                PppCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = ppp_coor_rotate(c, o);
            }
        }
    }
}

func void ppp_board_set(i32 x, i32 y, PppField field) {
    ppp_board.fields[x + y * 5] = field;
}

func PppField ppp_board_get(i32 x, i32 y) {
    return ppp_board.fields[x + y * 5];
}

func void ppp_board_init() {
    PppField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            ppp_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    ppp_board_set(0, 4, f);
    ppp_board.haveHead = 0;
    ppp_board.haveTail = 0;
}

func char ppp_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void ppp_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ppp_board.haveHead, ppp_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            PppField field = ppp_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ppp_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ppp_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ppp_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 ppp_board_check_fault(i32 xx, i32 yy, i32 expect) {
    PppField f = ppp_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 ppp_board_try_option(const PppOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        PppCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        PppField f = ppp_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (ppp_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (ppp_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (ppp_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (ppp_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (ppp_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (ppp_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ppp_board_clearflags(i32 x, i32 y) {
    ppp_board.fields[x + y * 5].expected = 0;
}

func void ppp_board_setExpected(i32 x, i32 y, u8 side) {
    ppp_board.fields[x + y * 5].expected = side;
}

func void ppp_board_add(const PppOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        PppCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        PppField field = ppp_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        ppp_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ppp_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            ppp_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            ppp_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            ppp_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            ppp_board.haveHead = 1;
            break;
        case Flags.Tail:
            ppp_board.haveTail = 1;
            break;
        }
    }
}

func void ppp_board_rem(const PppOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        PppCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        PppField field = ppp_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        ppp_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ppp_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            ppp_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            ppp_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            ppp_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            ppp_board.haveHead = 0;
            break;
        case Flags.Tail:
            ppp_board.haveTail = 0;
            break;
        }
    }
}

func void ppp_board_try_piece(u8 p) {
    if (p == PppNumPieces) {
        ppp_found++;
        io.printf("Found solution %u\n", ppp_found);
        ppp_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            PppField f = ppp_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<PppNumOptions; o++) {
                if (!ppp_board_try_option(&ppp_options[o][p], x, y)) {
                    ppp_board_add(&ppp_options[o][p], x, y, p);
                    ppp_board_try_piece(p+1);
                    ppp_board_rem(&ppp_options[o][p], x, y);
                }
                ppp_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE qqq ------------------------------------------

type QqqCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 qqq_found;
u64 qqq_tried;

type QqqField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type QqqBoard struct {
    QqqField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type QqqPiece struct {
    QqqCoor[4] side1;
    QqqCoor[4] side2;
}

type QqqOption struct {
    QqqCoor[4] parts;
}

QqqBoard qqq_board;

QqqPiece[] qqq_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
QqqOption[QqqNumOptions][QqqNumPieces] qqq_options;

const i32 QqqNumPieces = elemsof(qqq_pieces);
const i32 QqqNumOptions = 8;


func QqqCoor qqq_coor_rotate(QqqCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    QqqCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void qqq_calculate_rotations() {
    memset(qqq_options, 0, sizeof(qqq_options));
    for (u32 p=0; p<QqqNumPieces; p++) {
        const QqqPiece* pp = &qqq_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            QqqOption* o1 = &qqq_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                QqqCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = qqq_coor_rotate(c, o);
            }
            QqqOption* o2 = &qqq_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                QqqCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = qqq_coor_rotate(c, o);
            }
        }
    }
}

func void qqq_board_set(i32 x, i32 y, QqqField field) {
    qqq_board.fields[x + y * 5] = field;
}

func QqqField qqq_board_get(i32 x, i32 y) {
    return qqq_board.fields[x + y * 5];
}

func void qqq_board_init() {
    QqqField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            qqq_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    qqq_board_set(0, 4, f);
    qqq_board.haveHead = 0;
    qqq_board.haveTail = 0;
}

func char qqq_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void qqq_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", qqq_board.haveHead, qqq_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            QqqField field = qqq_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, qqq_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, qqq_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = qqq_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 qqq_board_check_fault(i32 xx, i32 yy, i32 expect) {
    QqqField f = qqq_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 qqq_board_try_option(const QqqOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        QqqCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        QqqField f = qqq_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (qqq_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (qqq_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (qqq_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (qqq_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (qqq_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (qqq_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void qqq_board_clearflags(i32 x, i32 y) {
    qqq_board.fields[x + y * 5].expected = 0;
}

func void qqq_board_setExpected(i32 x, i32 y, u8 side) {
    qqq_board.fields[x + y * 5].expected = side;
}

func void qqq_board_add(const QqqOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        QqqCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        QqqField field = qqq_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        qqq_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            qqq_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            qqq_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            qqq_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            qqq_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            qqq_board.haveHead = 1;
            break;
        case Flags.Tail:
            qqq_board.haveTail = 1;
            break;
        }
    }
}

func void qqq_board_rem(const QqqOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        QqqCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        QqqField field = qqq_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        qqq_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            qqq_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            qqq_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            qqq_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            qqq_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            qqq_board.haveHead = 0;
            break;
        case Flags.Tail:
            qqq_board.haveTail = 0;
            break;
        }
    }
}

func void qqq_board_try_piece(u8 p) {
    if (p == QqqNumPieces) {
        qqq_found++;
        io.printf("Found solution %u\n", qqq_found);
        qqq_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            QqqField f = qqq_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<QqqNumOptions; o++) {
                if (!qqq_board_try_option(&qqq_options[o][p], x, y)) {
                    qqq_board_add(&qqq_options[o][p], x, y, p);
                    qqq_board_try_piece(p+1);
                    qqq_board_rem(&qqq_options[o][p], x, y);
                }
                qqq_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE rrr ------------------------------------------

type RrrCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 rrr_found;
u64 rrr_tried;

type RrrField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type RrrBoard struct {
    RrrField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type RrrPiece struct {
    RrrCoor[4] side1;
    RrrCoor[4] side2;
}

type RrrOption struct {
    RrrCoor[4] parts;
}

RrrBoard rrr_board;

RrrPiece[] rrr_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
RrrOption[RrrNumOptions][RrrNumPieces] rrr_options;

const i32 RrrNumPieces = elemsof(rrr_pieces);
const i32 RrrNumOptions = 8;


func RrrCoor rrr_coor_rotate(RrrCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    RrrCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void rrr_calculate_rotations() {
    memset(rrr_options, 0, sizeof(rrr_options));
    for (u32 p=0; p<RrrNumPieces; p++) {
        const RrrPiece* pp = &rrr_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            RrrOption* o1 = &rrr_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                RrrCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = rrr_coor_rotate(c, o);
            }
            RrrOption* o2 = &rrr_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                RrrCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = rrr_coor_rotate(c, o);
            }
        }
    }
}

func void rrr_board_set(i32 x, i32 y, RrrField field) {
    rrr_board.fields[x + y * 5] = field;
}

func RrrField rrr_board_get(i32 x, i32 y) {
    return rrr_board.fields[x + y * 5];
}

func void rrr_board_init() {
    RrrField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            rrr_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    rrr_board_set(0, 4, f);
    rrr_board.haveHead = 0;
    rrr_board.haveTail = 0;
}

func char rrr_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void rrr_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", rrr_board.haveHead, rrr_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            RrrField field = rrr_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, rrr_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, rrr_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = rrr_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 rrr_board_check_fault(i32 xx, i32 yy, i32 expect) {
    RrrField f = rrr_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 rrr_board_try_option(const RrrOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        RrrCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        RrrField f = rrr_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (rrr_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (rrr_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (rrr_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (rrr_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (rrr_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (rrr_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void rrr_board_clearflags(i32 x, i32 y) {
    rrr_board.fields[x + y * 5].expected = 0;
}

func void rrr_board_setExpected(i32 x, i32 y, u8 side) {
    rrr_board.fields[x + y * 5].expected = side;
}

func void rrr_board_add(const RrrOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        RrrCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        RrrField field = rrr_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        rrr_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            rrr_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            rrr_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            rrr_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            rrr_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            rrr_board.haveHead = 1;
            break;
        case Flags.Tail:
            rrr_board.haveTail = 1;
            break;
        }
    }
}

func void rrr_board_rem(const RrrOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        RrrCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        RrrField field = rrr_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        rrr_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            rrr_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            rrr_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            rrr_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            rrr_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            rrr_board.haveHead = 0;
            break;
        case Flags.Tail:
            rrr_board.haveTail = 0;
            break;
        }
    }
}

func void rrr_board_try_piece(u8 p) {
    if (p == RrrNumPieces) {
        rrr_found++;
        io.printf("Found solution %u\n", rrr_found);
        rrr_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            RrrField f = rrr_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<RrrNumOptions; o++) {
                if (!rrr_board_try_option(&rrr_options[o][p], x, y)) {
                    rrr_board_add(&rrr_options[o][p], x, y, p);
                    rrr_board_try_piece(p+1);
                    rrr_board_rem(&rrr_options[o][p], x, y);
                }
                rrr_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE sss ------------------------------------------

type SssCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 sss_found;
u64 sss_tried;

type SssField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type SssBoard struct {
    SssField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type SssPiece struct {
    SssCoor[4] side1;
    SssCoor[4] side2;
}

type SssOption struct {
    SssCoor[4] parts;
}

SssBoard sss_board;

SssPiece[] sss_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
SssOption[SssNumOptions][SssNumPieces] sss_options;

const i32 SssNumPieces = elemsof(sss_pieces);
const i32 SssNumOptions = 8;


func SssCoor sss_coor_rotate(SssCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    SssCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void sss_calculate_rotations() {
    memset(sss_options, 0, sizeof(sss_options));
    for (u32 p=0; p<SssNumPieces; p++) {
        const SssPiece* pp = &sss_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            SssOption* o1 = &sss_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                SssCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = sss_coor_rotate(c, o);
            }
            SssOption* o2 = &sss_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                SssCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = sss_coor_rotate(c, o);
            }
        }
    }
}

func void sss_board_set(i32 x, i32 y, SssField field) {
    sss_board.fields[x + y * 5] = field;
}

func SssField sss_board_get(i32 x, i32 y) {
    return sss_board.fields[x + y * 5];
}

func void sss_board_init() {
    SssField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            sss_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    sss_board_set(0, 4, f);
    sss_board.haveHead = 0;
    sss_board.haveTail = 0;
}

func char sss_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void sss_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", sss_board.haveHead, sss_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            SssField field = sss_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, sss_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, sss_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = sss_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 sss_board_check_fault(i32 xx, i32 yy, i32 expect) {
    SssField f = sss_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 sss_board_try_option(const SssOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        SssCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        SssField f = sss_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (sss_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (sss_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (sss_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (sss_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (sss_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (sss_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void sss_board_clearflags(i32 x, i32 y) {
    sss_board.fields[x + y * 5].expected = 0;
}

func void sss_board_setExpected(i32 x, i32 y, u8 side) {
    sss_board.fields[x + y * 5].expected = side;
}

func void sss_board_add(const SssOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        SssCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        SssField field = sss_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        sss_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            sss_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            sss_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            sss_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            sss_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            sss_board.haveHead = 1;
            break;
        case Flags.Tail:
            sss_board.haveTail = 1;
            break;
        }
    }
}

func void sss_board_rem(const SssOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        SssCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        SssField field = sss_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        sss_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            sss_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            sss_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            sss_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            sss_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            sss_board.haveHead = 0;
            break;
        case Flags.Tail:
            sss_board.haveTail = 0;
            break;
        }
    }
}

func void sss_board_try_piece(u8 p) {
    if (p == SssNumPieces) {
        sss_found++;
        io.printf("Found solution %u\n", sss_found);
        sss_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            SssField f = sss_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<SssNumOptions; o++) {
                if (!sss_board_try_option(&sss_options[o][p], x, y)) {
                    sss_board_add(&sss_options[o][p], x, y, p);
                    sss_board_try_piece(p+1);
                    sss_board_rem(&sss_options[o][p], x, y);
                }
                sss_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ttt ------------------------------------------

type TttCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 ttt_found;
u64 ttt_tried;

type TttField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type TttBoard struct {
    TttField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type TttPiece struct {
    TttCoor[4] side1;
    TttCoor[4] side2;
}

type TttOption struct {
    TttCoor[4] parts;
}

TttBoard ttt_board;

TttPiece[] ttt_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
TttOption[TttNumOptions][TttNumPieces] ttt_options;

const i32 TttNumPieces = elemsof(ttt_pieces);
const i32 TttNumOptions = 8;


func TttCoor ttt_coor_rotate(TttCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    TttCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ttt_calculate_rotations() {
    memset(ttt_options, 0, sizeof(ttt_options));
    for (u32 p=0; p<TttNumPieces; p++) {
        const TttPiece* pp = &ttt_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            TttOption* o1 = &ttt_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                TttCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = ttt_coor_rotate(c, o);
            }
            TttOption* o2 = &ttt_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                TttCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = ttt_coor_rotate(c, o);
            }
        }
    }
}

func void ttt_board_set(i32 x, i32 y, TttField field) {
    ttt_board.fields[x + y * 5] = field;
}

func TttField ttt_board_get(i32 x, i32 y) {
    return ttt_board.fields[x + y * 5];
}

func void ttt_board_init() {
    TttField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            ttt_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    ttt_board_set(0, 4, f);
    ttt_board.haveHead = 0;
    ttt_board.haveTail = 0;
}

func char ttt_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void ttt_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ttt_board.haveHead, ttt_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            TttField field = ttt_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ttt_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ttt_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ttt_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 ttt_board_check_fault(i32 xx, i32 yy, i32 expect) {
    TttField f = ttt_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 ttt_board_try_option(const TttOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        TttCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        TttField f = ttt_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (ttt_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (ttt_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (ttt_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (ttt_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (ttt_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (ttt_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ttt_board_clearflags(i32 x, i32 y) {
    ttt_board.fields[x + y * 5].expected = 0;
}

func void ttt_board_setExpected(i32 x, i32 y, u8 side) {
    ttt_board.fields[x + y * 5].expected = side;
}

func void ttt_board_add(const TttOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        TttCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        TttField field = ttt_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        ttt_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ttt_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            ttt_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            ttt_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            ttt_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            ttt_board.haveHead = 1;
            break;
        case Flags.Tail:
            ttt_board.haveTail = 1;
            break;
        }
    }
}

func void ttt_board_rem(const TttOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        TttCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        TttField field = ttt_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        ttt_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            ttt_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            ttt_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            ttt_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            ttt_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            ttt_board.haveHead = 0;
            break;
        case Flags.Tail:
            ttt_board.haveTail = 0;
            break;
        }
    }
}

func void ttt_board_try_piece(u8 p) {
    if (p == TttNumPieces) {
        ttt_found++;
        io.printf("Found solution %u\n", ttt_found);
        ttt_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            TttField f = ttt_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<TttNumOptions; o++) {
                if (!ttt_board_try_option(&ttt_options[o][p], x, y)) {
                    ttt_board_add(&ttt_options[o][p], x, y, p);
                    ttt_board_try_piece(p+1);
                    ttt_board_rem(&ttt_options[o][p], x, y);
                }
                ttt_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE uuu ------------------------------------------

type UuuCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 uuu_found;
u64 uuu_tried;

type UuuField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type UuuBoard struct {
    UuuField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type UuuPiece struct {
    UuuCoor[4] side1;
    UuuCoor[4] side2;
}

type UuuOption struct {
    UuuCoor[4] parts;
}

UuuBoard uuu_board;

UuuPiece[] uuu_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
UuuOption[UuuNumOptions][UuuNumPieces] uuu_options;

const i32 UuuNumPieces = elemsof(uuu_pieces);
const i32 UuuNumOptions = 8;


func UuuCoor uuu_coor_rotate(UuuCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    UuuCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void uuu_calculate_rotations() {
    memset(uuu_options, 0, sizeof(uuu_options));
    for (u32 p=0; p<UuuNumPieces; p++) {
        const UuuPiece* pp = &uuu_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            UuuOption* o1 = &uuu_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                UuuCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = uuu_coor_rotate(c, o);
            }
            UuuOption* o2 = &uuu_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                UuuCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = uuu_coor_rotate(c, o);
            }
        }
    }
}

func void uuu_board_set(i32 x, i32 y, UuuField field) {
    uuu_board.fields[x + y * 5] = field;
}

func UuuField uuu_board_get(i32 x, i32 y) {
    return uuu_board.fields[x + y * 5];
}

func void uuu_board_init() {
    UuuField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            uuu_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    uuu_board_set(0, 4, f);
    uuu_board.haveHead = 0;
    uuu_board.haveTail = 0;
}

func char uuu_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void uuu_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", uuu_board.haveHead, uuu_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            UuuField field = uuu_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, uuu_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, uuu_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = uuu_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 uuu_board_check_fault(i32 xx, i32 yy, i32 expect) {
    UuuField f = uuu_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 uuu_board_try_option(const UuuOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        UuuCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        UuuField f = uuu_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (uuu_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (uuu_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (uuu_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (uuu_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (uuu_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (uuu_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void uuu_board_clearflags(i32 x, i32 y) {
    uuu_board.fields[x + y * 5].expected = 0;
}

func void uuu_board_setExpected(i32 x, i32 y, u8 side) {
    uuu_board.fields[x + y * 5].expected = side;
}

func void uuu_board_add(const UuuOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        UuuCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        UuuField field = uuu_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        uuu_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            uuu_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            uuu_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            uuu_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            uuu_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            uuu_board.haveHead = 1;
            break;
        case Flags.Tail:
            uuu_board.haveTail = 1;
            break;
        }
    }
}

func void uuu_board_rem(const UuuOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        UuuCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        UuuField field = uuu_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        uuu_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            uuu_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            uuu_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            uuu_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            uuu_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            uuu_board.haveHead = 0;
            break;
        case Flags.Tail:
            uuu_board.haveTail = 0;
            break;
        }
    }
}

func void uuu_board_try_piece(u8 p) {
    if (p == UuuNumPieces) {
        uuu_found++;
        io.printf("Found solution %u\n", uuu_found);
        uuu_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            UuuField f = uuu_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<UuuNumOptions; o++) {
                if (!uuu_board_try_option(&uuu_options[o][p], x, y)) {
                    uuu_board_add(&uuu_options[o][p], x, y, p);
                    uuu_board_try_piece(p+1);
                    uuu_board_rem(&uuu_options[o][p], x, y);
                }
                uuu_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE vvv ------------------------------------------

type VvvCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 vvv_found;
u64 vvv_tried;

type VvvField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type VvvBoard struct {
    VvvField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type VvvPiece struct {
    VvvCoor[4] side1;
    VvvCoor[4] side2;
}

type VvvOption struct {
    VvvCoor[4] parts;
}

VvvBoard vvv_board;

VvvPiece[] vvv_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
VvvOption[VvvNumOptions][VvvNumPieces] vvv_options;

const i32 VvvNumPieces = elemsof(vvv_pieces);
const i32 VvvNumOptions = 8;


func VvvCoor vvv_coor_rotate(VvvCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    VvvCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void vvv_calculate_rotations() {
    memset(vvv_options, 0, sizeof(vvv_options));
    for (u32 p=0; p<VvvNumPieces; p++) {
        const VvvPiece* pp = &vvv_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            VvvOption* o1 = &vvv_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                VvvCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = vvv_coor_rotate(c, o);
            }
            VvvOption* o2 = &vvv_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                VvvCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = vvv_coor_rotate(c, o);
            }
        }
    }
}

func void vvv_board_set(i32 x, i32 y, VvvField field) {
    vvv_board.fields[x + y * 5] = field;
}

func VvvField vvv_board_get(i32 x, i32 y) {
    return vvv_board.fields[x + y * 5];
}

func void vvv_board_init() {
    VvvField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            vvv_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    vvv_board_set(0, 4, f);
    vvv_board.haveHead = 0;
    vvv_board.haveTail = 0;
}

func char vvv_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void vvv_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", vvv_board.haveHead, vvv_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            VvvField field = vvv_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, vvv_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, vvv_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = vvv_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 vvv_board_check_fault(i32 xx, i32 yy, i32 expect) {
    VvvField f = vvv_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 vvv_board_try_option(const VvvOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        VvvCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        VvvField f = vvv_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (vvv_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (vvv_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (vvv_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (vvv_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (vvv_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (vvv_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void vvv_board_clearflags(i32 x, i32 y) {
    vvv_board.fields[x + y * 5].expected = 0;
}

func void vvv_board_setExpected(i32 x, i32 y, u8 side) {
    vvv_board.fields[x + y * 5].expected = side;
}

func void vvv_board_add(const VvvOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        VvvCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        VvvField field = vvv_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        vvv_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            vvv_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            vvv_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            vvv_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            vvv_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            vvv_board.haveHead = 1;
            break;
        case Flags.Tail:
            vvv_board.haveTail = 1;
            break;
        }
    }
}

func void vvv_board_rem(const VvvOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        VvvCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        VvvField field = vvv_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        vvv_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            vvv_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            vvv_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            vvv_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            vvv_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            vvv_board.haveHead = 0;
            break;
        case Flags.Tail:
            vvv_board.haveTail = 0;
            break;
        }
    }
}

func void vvv_board_try_piece(u8 p) {
    if (p == VvvNumPieces) {
        vvv_found++;
        io.printf("Found solution %u\n", vvv_found);
        vvv_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            VvvField f = vvv_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<VvvNumOptions; o++) {
                if (!vvv_board_try_option(&vvv_options[o][p], x, y)) {
                    vvv_board_add(&vvv_options[o][p], x, y, p);
                    vvv_board_try_piece(p+1);
                    vvv_board_rem(&vvv_options[o][p], x, y);
                }
                vvv_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE www ------------------------------------------

type WwwCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 www_found;
u64 www_tried;

type WwwField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type WwwBoard struct {
    WwwField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type WwwPiece struct {
    WwwCoor[4] side1;
    WwwCoor[4] side2;
}

type WwwOption struct {
    WwwCoor[4] parts;
}

WwwBoard www_board;

WwwPiece[] www_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
WwwOption[WwwNumOptions][WwwNumPieces] www_options;

const i32 WwwNumPieces = elemsof(www_pieces);
const i32 WwwNumOptions = 8;


func WwwCoor www_coor_rotate(WwwCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    WwwCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void www_calculate_rotations() {
    memset(www_options, 0, sizeof(www_options));
    for (u32 p=0; p<WwwNumPieces; p++) {
        const WwwPiece* pp = &www_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            WwwOption* o1 = &www_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                WwwCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = www_coor_rotate(c, o);
            }
            WwwOption* o2 = &www_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                WwwCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = www_coor_rotate(c, o);
            }
        }
    }
}

func void www_board_set(i32 x, i32 y, WwwField field) {
    www_board.fields[x + y * 5] = field;
}

func WwwField www_board_get(i32 x, i32 y) {
    return www_board.fields[x + y * 5];
}

func void www_board_init() {
    WwwField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            www_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    www_board_set(0, 4, f);
    www_board.haveHead = 0;
    www_board.haveTail = 0;
}

func char www_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void www_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", www_board.haveHead, www_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            WwwField field = www_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, www_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, www_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = www_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 www_board_check_fault(i32 xx, i32 yy, i32 expect) {
    WwwField f = www_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 www_board_try_option(const WwwOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        WwwCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        WwwField f = www_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (www_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (www_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (www_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (www_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (www_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (www_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void www_board_clearflags(i32 x, i32 y) {
    www_board.fields[x + y * 5].expected = 0;
}

func void www_board_setExpected(i32 x, i32 y, u8 side) {
    www_board.fields[x + y * 5].expected = side;
}

func void www_board_add(const WwwOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        WwwCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        WwwField field = www_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        www_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            www_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            www_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            www_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            www_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            www_board.haveHead = 1;
            break;
        case Flags.Tail:
            www_board.haveTail = 1;
            break;
        }
    }
}

func void www_board_rem(const WwwOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        WwwCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        WwwField field = www_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        www_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            www_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            www_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            www_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            www_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            www_board.haveHead = 0;
            break;
        case Flags.Tail:
            www_board.haveTail = 0;
            break;
        }
    }
}

func void www_board_try_piece(u8 p) {
    if (p == WwwNumPieces) {
        www_found++;
        io.printf("Found solution %u\n", www_found);
        www_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            WwwField f = www_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<WwwNumOptions; o++) {
                if (!www_board_try_option(&www_options[o][p], x, y)) {
                    www_board_add(&www_options[o][p], x, y, p);
                    www_board_try_piece(p+1);
                    www_board_rem(&www_options[o][p], x, y);
                }
                www_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE xxx ------------------------------------------

type XxxCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 xxx_found;
u64 xxx_tried;

type XxxField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type XxxBoard struct {
    XxxField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type XxxPiece struct {
    XxxCoor[4] side1;
    XxxCoor[4] side2;
}

type XxxOption struct {
    XxxCoor[4] parts;
}

XxxBoard xxx_board;

XxxPiece[] xxx_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
XxxOption[XxxNumOptions][XxxNumPieces] xxx_options;

const i32 XxxNumPieces = elemsof(xxx_pieces);
const i32 XxxNumOptions = 8;


func XxxCoor xxx_coor_rotate(XxxCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    XxxCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void xxx_calculate_rotations() {
    memset(xxx_options, 0, sizeof(xxx_options));
    for (u32 p=0; p<XxxNumPieces; p++) {
        const XxxPiece* pp = &xxx_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            XxxOption* o1 = &xxx_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                XxxCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = xxx_coor_rotate(c, o);
            }
            XxxOption* o2 = &xxx_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                XxxCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = xxx_coor_rotate(c, o);
            }
        }
    }
}

func void xxx_board_set(i32 x, i32 y, XxxField field) {
    xxx_board.fields[x + y * 5] = field;
}

func XxxField xxx_board_get(i32 x, i32 y) {
    return xxx_board.fields[x + y * 5];
}

func void xxx_board_init() {
    XxxField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            xxx_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    xxx_board_set(0, 4, f);
    xxx_board.haveHead = 0;
    xxx_board.haveTail = 0;
}

func char xxx_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void xxx_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", xxx_board.haveHead, xxx_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            XxxField field = xxx_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, xxx_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, xxx_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = xxx_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 xxx_board_check_fault(i32 xx, i32 yy, i32 expect) {
    XxxField f = xxx_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 xxx_board_try_option(const XxxOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        XxxCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        XxxField f = xxx_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (xxx_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (xxx_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (xxx_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (xxx_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (xxx_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (xxx_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void xxx_board_clearflags(i32 x, i32 y) {
    xxx_board.fields[x + y * 5].expected = 0;
}

func void xxx_board_setExpected(i32 x, i32 y, u8 side) {
    xxx_board.fields[x + y * 5].expected = side;
}

func void xxx_board_add(const XxxOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        XxxCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        XxxField field = xxx_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        xxx_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            xxx_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            xxx_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            xxx_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            xxx_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            xxx_board.haveHead = 1;
            break;
        case Flags.Tail:
            xxx_board.haveTail = 1;
            break;
        }
    }
}

func void xxx_board_rem(const XxxOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        XxxCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        XxxField field = xxx_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        xxx_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            xxx_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            xxx_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            xxx_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            xxx_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            xxx_board.haveHead = 0;
            break;
        case Flags.Tail:
            xxx_board.haveTail = 0;
            break;
        }
    }
}

func void xxx_board_try_piece(u8 p) {
    if (p == XxxNumPieces) {
        xxx_found++;
        io.printf("Found solution %u\n", xxx_found);
        xxx_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            XxxField f = xxx_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<XxxNumOptions; o++) {
                if (!xxx_board_try_option(&xxx_options[o][p], x, y)) {
                    xxx_board_add(&xxx_options[o][p], x, y, p);
                    xxx_board_try_piece(p+1);
                    xxx_board_rem(&xxx_options[o][p], x, y);
                }
                xxx_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE yyy ------------------------------------------

type YyyCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 yyy_found;
u64 yyy_tried;

type YyyField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type YyyBoard struct {
    YyyField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type YyyPiece struct {
    YyyCoor[4] side1;
    YyyCoor[4] side2;
}

type YyyOption struct {
    YyyCoor[4] parts;
}

YyyBoard yyy_board;

YyyPiece[] yyy_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
YyyOption[YyyNumOptions][YyyNumPieces] yyy_options;

const i32 YyyNumPieces = elemsof(yyy_pieces);
const i32 YyyNumOptions = 8;


func YyyCoor yyy_coor_rotate(YyyCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    YyyCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void yyy_calculate_rotations() {
    memset(yyy_options, 0, sizeof(yyy_options));
    for (u32 p=0; p<YyyNumPieces; p++) {
        const YyyPiece* pp = &yyy_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            YyyOption* o1 = &yyy_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                YyyCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = yyy_coor_rotate(c, o);
            }
            YyyOption* o2 = &yyy_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                YyyCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = yyy_coor_rotate(c, o);
            }
        }
    }
}

func void yyy_board_set(i32 x, i32 y, YyyField field) {
    yyy_board.fields[x + y * 5] = field;
}

func YyyField yyy_board_get(i32 x, i32 y) {
    return yyy_board.fields[x + y * 5];
}

func void yyy_board_init() {
    YyyField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            yyy_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    yyy_board_set(0, 4, f);
    yyy_board.haveHead = 0;
    yyy_board.haveTail = 0;
}

func char yyy_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void yyy_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", yyy_board.haveHead, yyy_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            YyyField field = yyy_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, yyy_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, yyy_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = yyy_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 yyy_board_check_fault(i32 xx, i32 yy, i32 expect) {
    YyyField f = yyy_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 yyy_board_try_option(const YyyOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        YyyCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        YyyField f = yyy_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (yyy_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (yyy_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (yyy_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (yyy_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (yyy_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (yyy_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void yyy_board_clearflags(i32 x, i32 y) {
    yyy_board.fields[x + y * 5].expected = 0;
}

func void yyy_board_setExpected(i32 x, i32 y, u8 side) {
    yyy_board.fields[x + y * 5].expected = side;
}

func void yyy_board_add(const YyyOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        YyyCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        YyyField field = yyy_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        yyy_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            yyy_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            yyy_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            yyy_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            yyy_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            yyy_board.haveHead = 1;
            break;
        case Flags.Tail:
            yyy_board.haveTail = 1;
            break;
        }
    }
}

func void yyy_board_rem(const YyyOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        YyyCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        YyyField field = yyy_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        yyy_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            yyy_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            yyy_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            yyy_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            yyy_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            yyy_board.haveHead = 0;
            break;
        case Flags.Tail:
            yyy_board.haveTail = 0;
            break;
        }
    }
}

func void yyy_board_try_piece(u8 p) {
    if (p == YyyNumPieces) {
        yyy_found++;
        io.printf("Found solution %u\n", yyy_found);
        yyy_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            YyyField f = yyy_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<YyyNumOptions; o++) {
                if (!yyy_board_try_option(&yyy_options[o][p], x, y)) {
                    yyy_board_add(&yyy_options[o][p], x, y, p);
                    yyy_board_try_piece(p+1);
                    yyy_board_rem(&yyy_options[o][p], x, y);
                }
                yyy_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE zzz ------------------------------------------

type ZzzCoor struct {
    i8 x;
    i8 y;
    u8 flags;
}

u32 zzz_found;
u64 zzz_tried;

type ZzzField struct {
#if 0
    FieldStatus status : 2;
    u32 piece_id : 4;
    u32 flags : 3;
    u32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    u8 piece_id;
    u8 flags;
    u8 expected;  // set by other pieces
}

type ZzzBoard struct {
    ZzzField[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type ZzzPiece struct {
    ZzzCoor[4] side1;
    ZzzCoor[4] side2;
}

type ZzzOption struct {
    ZzzCoor[4] parts;
}

ZzzBoard zzz_board;

ZzzPiece[] zzz_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, Flags.North }, { 1, 1, Flags.South }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, Flags.West }, { 2, 1, Flags.South } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, Flags.North }, { 1, 0, Flags.East } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.North }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, Flags.Head } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, Flags.East }, { 1, 0, Flags.East } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.Tail }, { 1, 0, 0 } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 1, 0, Flags.Tail } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.Head } },
        .side2 = { { 0, 0, Flags.South }, { 0, 1, 0 }, { 0, 2, Flags.West } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, Flags.West }, { 0, 1, Flags.North } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
ZzzOption[ZzzNumOptions][ZzzNumPieces] zzz_options;

const i32 ZzzNumPieces = elemsof(zzz_pieces);
const i32 ZzzNumOptions = 8;


func ZzzCoor zzz_coor_rotate(ZzzCoor input, u32 rotation) @(unused) {
    i8 x = input.x;
    i8 y = input.y;
    i8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    u8 flags = input.flags;  // keep Flags.Head/Flags.Tail, rotate NESW
    if (rotation > 0 && flags >= Flags.North && flags <= Flags.West) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    ZzzCoor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void zzz_calculate_rotations() {
    memset(zzz_options, 0, sizeof(zzz_options));
    for (u32 p=0; p<ZzzNumPieces; p++) {
        const ZzzPiece* pp = &zzz_pieces[p];
        for (u32 o=0; o<4; o++) {  // 4 rotations
            ZzzOption* o1 = &zzz_options[o][p];
            for (u32 i=0; i<4; i++) {  // side1
                ZzzCoor c = pp.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o1.parts[i] = zzz_coor_rotate(c, o);
            }
            ZzzOption* o2 = &zzz_options[o+4][p];
            for (u32 i=0; i<4; i++) {  // side2
                ZzzCoor c = pp.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                o2.parts[i] = zzz_coor_rotate(c, o);
            }
        }
    }
}

func void zzz_board_set(i32 x, i32 y, ZzzField field) {
    zzz_board.fields[x + y * 5] = field;
}

func ZzzField zzz_board_get(i32 x, i32 y) {
    return zzz_board.fields[x + y * 5];
}

func void zzz_board_init() {
    ZzzField f;
    f.status = FieldStatus.Free;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (i32 y=0; y<5; y++) {
        for (i32 x=0; x<5; x++) {
            zzz_board_set(x, y, f);
        }
    }
    f.status = FieldStatus.Blocked;
    zzz_board_set(0, 4, f);
    zzz_board.haveHead = 0;
    zzz_board.haveTail = 0;
}

func char zzz_flags2char(i32 flags) {
    char f = ' ';
    switch (flags) {
    case Flags.North:
        f = 'N';
        break;
    case Flags.East:
        f = 'E';
        break;
    case Flags.South:
        f = 'S';
        break;
    case Flags.West:
        f = 'W';
        break;
    case Flags.Head:
        f = 'H';
        break;
    case Flags.Tail:
        f = 'T';
        break;
    }
    return f;
}

func void zzz_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", zzz_board.haveHead, zzz_board.haveTail);
    for (i32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (i32 x=0; x<5; x++) {
            *cp++ = '|';
            ZzzField field = zzz_board.fields[x + y * 5];
            switch (field.status) {
            case FieldStatus.Free:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, zzz_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FieldStatus.Blocked:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                i32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, zzz_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = zzz_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func i32 zzz_board_check_fault(i32 xx, i32 yy, i32 expect) {
    ZzzField f = zzz_board_get(xx, yy);
    switch (f.status) {
    case FieldStatus.Free:
        if (f.expected && f.expected != expect) return 1;
        break;
    case FieldStatus.Blocked:
        return 1;
    case FieldStatus.Taken:
        if (f.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func i32 zzz_board_try_option(const ZzzOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        ZzzCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        i32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        i32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        ZzzField f = zzz_board_get(xx, yy);
        if (f.status != FieldStatus.Free) return 1;
        if (f.expected != 0 && f.expected != c.flags) return 1;
        switch (c.flags) {
        case Flags.North:
            if (yy == 4) return 1;
            if (zzz_board_check_fault(xx, yy+1, Flags.South)) return 1;
            break;
        case Flags.East:
            if (xx == 4) return 1;
            if (zzz_board_check_fault(xx+1, yy, Flags.West)) return 1;
            break;
        case Flags.South:
            if (yy == 0) return 1;
            if (zzz_board_check_fault(xx, yy-1, Flags.North)) return 1;
            break;
        case Flags.West:
            if (xx == 0) return 1;
            if (zzz_board_check_fault(xx-1, yy, Flags.East)) return 1;
            break;
        case Flags.Head:
            if (zzz_board.haveHead) return 1;
            break;
        case Flags.Tail:
            if (zzz_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void zzz_board_clearflags(i32 x, i32 y) {
    zzz_board.fields[x + y * 5].expected = 0;
}

func void zzz_board_setExpected(i32 x, i32 y, u8 side) {
    zzz_board.fields[x + y * 5].expected = side;
}

func void zzz_board_add(const ZzzOption* pp, i32 x, i32 y, u8 id) {
    for (u32 i=0; i<4; i++) {
        ZzzCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        ZzzField field = zzz_board_get(xx, yy);
        //assert(field.status == FieldStatus.Free);
        field.status = FieldStatus.Taken;
        field.piece_id = id;
        field.flags = c.flags;
        zzz_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            zzz_board_setExpected(xx, yy+1, Flags.South);
            break;
        case Flags.East:
            zzz_board_setExpected(xx+1, yy, Flags.West);
            break;
        case Flags.South:
            field.flags = Flags.North;
            zzz_board_setExpected(xx, yy-1, Flags.North);
            break;
        case Flags.West:
            zzz_board_setExpected(xx-1, yy, Flags.East);
            break;
        case Flags.Head:
            zzz_board.haveHead = 1;
            break;
        case Flags.Tail:
            zzz_board.haveTail = 1;
            break;
        }
    }
}

func void zzz_board_rem(const ZzzOption* pp, i32 x, i32 y) {
    for (u32 i=0; i<4; i++) {
        ZzzCoor c = pp.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        i32 xx = x + c.x;
        i32 yy = y + c.y;
        ZzzField field = zzz_board_get(xx, yy);
        field.status = FieldStatus.Free;
        field.piece_id = 0;
        field.flags = 0;
        zzz_board_set(xx, yy, field);
        switch (c.flags) {
        case Flags.North:
            zzz_board_clearflags(xx, yy+1);
            break;
        case Flags.East:
            zzz_board_clearflags(xx+1, yy);
            break;
        case Flags.South:
            zzz_board_clearflags(xx, yy-1);
            break;
        case Flags.West:
            zzz_board_clearflags(xx-1, yy);
            break;
        case Flags.Head:
            zzz_board.haveHead = 0;
            break;
        case Flags.Tail:
            zzz_board.haveTail = 0;
            break;
        }
    }
}

func void zzz_board_try_piece(u8 p) {
    if (p == ZzzNumPieces) {
        zzz_found++;
        io.printf("Found solution %u\n", zzz_found);
        zzz_board_print();
        return;
    }
    for (i32 y=4; y>=0; y--) {
        for (i32 x=0; x<5; x++) {
            ZzzField f = zzz_board_get(x, y);
            if (f.status != FieldStatus.Free) continue;
            for (u32 o=0; o<ZzzNumOptions; o++) {
                if (!zzz_board_try_option(&zzz_options[o][p], x, y)) {
                    zzz_board_add(&zzz_options[o][p], x, y, p);
                    zzz_board_try_piece(p+1);
                    zzz_board_rem(&zzz_options[o][p], x, y);
                }
                zzz_tried++;
                if (p==0) break;
            }
        }
    }
}

